# 智能IP地址池 (IPPool)

本文档详细介绍了 `IPPool` 接口及其默认实现 `LocalIPPool` 的设计理念、核心功能和使用方法。这是一个为高性能网络应用设计的、能够自动适应运行环境的智能IP地址池。

## 设计理念

在现代网络应用中，尤其是在云服务和VPS环境中，我们经常面临两种情况：
1.  服务商提供了一个或多个固定的IPv4地址。
2.  服务商额外提供了一个完整的IPv6子网（例如 `/64`），允许我们使用其中海量的地址。

`LocalIPPool` 的核心设计目标就是为了优雅地处理这种混合环境，并最大化地利用可用的IP资源，同时通过 `IPPool` 接口保持代码的简洁、可测试和可扩展性。

## 核心功能

- **接口驱动设计**：模块提供了 `IPPool` 接口，将IP池的行为（“能做什么”）与具体实现（“如何做”）分离。业务逻辑应始终依赖于 `IPPool` 接口，这使得未来可以轻松替换IP池的实现（例如，从本地生成切换为从远程服务获取），而无需修改任何业务代码。

- **环境自适应**：这是`LocalIPPool`最关键的特性。在初始化时，它会**自动检测**当前系统的网络配置，判断您提供的IPv6子网是否真实可用。
    - 如果可用，它将进入**“IPv4+动态IPv6”**模式，在后台持续生成新的IPv6地址。
    - 如果不可用（例如，代码部署在只有IPv4的服务器或您的本地开发机上），它将自动、静默地**降级为“仅IPv4”**模式。

- **动态IPv6生成**：在支持IPv6的环境下，它能从您提供的子网（无论是公网还是私有网络）中，为每一次IP获取请求提供一个**全新的、随机的IPv6地址**。这对于需要高隐蔽性或大量出站连接的应用场景（如爬虫、API请求）极为有用。

- **统一的调用接口**：无论底层工作在何种模式，使用者都只需要调用 `IPPool` 接口中定义的 `GetIP()` 方法来获取地址。

- **并发安全与高性能**：
    - 内部使用`chan`作为生产者-消费者队列来传递生成的IPv6地址，这是Go语言中最高效、最原生的并发模型。
    - 后台goroutine会预先生成一批IP地址放入缓冲区，确保消费者能无延迟地快速获取。
    - 实现了标准的 `io.Closer` 接口，可以通过 `defer pool.Close()` 来优雅地停止后台任务，防止goroutine泄漏。

## 使用方法

### 1. 导入

```go
import "path/to/your/src"
```

### 2. 初始化IP池

使用 `NewLocalIPPool` 函数创建实例。**注意：变量应声明为 `src.IPPool` 接口类型。**

```go
var ipPool src.IPPool // 关键：依赖于接口，而非具体实现
var err error

// 场景A：在拥有公网IPv6子网的VPS上
ipv4s := []string{"172.93.47.57"}
ipv6Subnet := "2607:8700:5500:2943::/64"
ipPool, err = src.NewLocalIPPool(ipv4s, ipv6Subnet)
if err != nil {
    log.Fatalf("无法初始化IP池: %v", err)
}
// 程序将输出: "检测到可用的IPv6子网，已启用IPv6动态生成模式。"

// 场景B：在只有IPv4的服务器或本地开发机上运行同样的代码
// ipPool, err = src.NewLocalIPPool(ipv4s, ipv6Subnet)
// 程序将输出: "未在当前网络环境中检测到指定的IPv6子网，已降级为仅IPv4模式。"
```

### 3. 获取IP地址

使用 `GetIP()` 方法从池中获取一个IP地址。

```go
// 在支持IPv6的模式下:
// 每次调用都会返回一个全新的、随机的IPv6地址。
// 例如: 2607:8700:5500:2943:abcd:1234:efff:5678
ip := ipPool.GetIP()
fmt.Printf("获取到的IP: %s\n", ip.String())

// 在仅IPv4的模式下:
// 每次调用都会从您提供的列表中随机返回一个IPv4地址。
// 例如: 172.93.47.57
ip := ipPool.GetIP()
fmt.Printf("获取到的IP: %s\n", ip.String())
```

### 4. 关闭IP池

在您的应用程序准备退出时，调用 `Close()` 方法来确保后台的goroutine被干净地关闭。这通常在 `main` 函数的末尾通过 `defer` 来完成。

```go
func main() {
    // ... 初始化 ipPool ...
    defer ipPool.Close()

    // ... 您的应用主逻辑 ...
}
```

## 设计细节：如何实现环境自适应？

`NewLocalIPPool` 在内部调用了一个名为 `isSubnetConfigured` 的辅助函数。该函数会：
1. 遍历当前操作系统上所有**处于活动状态 (UP)** 且**非回环 (non-loopback)** 的网络接口。
2. 获取每个接口上配置的所有IP地址。
3. 检查是否有任何一个已配置的IP地址，位于您在初始化时提供的IPv6大子网（例如`/64`）之内。

只要找到一个匹配项，就证明当前环境确实配置了该IPv6子网，可以安全地启用动态生成功能。这种设计确保了`LocalIPPool`不会在错误的环境中尝试生成和使用无法路由的IP地址。
